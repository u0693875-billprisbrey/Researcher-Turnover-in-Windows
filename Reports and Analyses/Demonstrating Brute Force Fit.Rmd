---
title: "Demonstrating Brute Force Fit"
author: "Bill Prisbrey"
date: "2025-10-21"
output:
  html_document:
    keep_md: true
params:
  showPI: true
  showAll: false
---


```{r include=FALSE}


# Author's notes:

# I want a handful of flowcharts showing the breakdown of the individual journey,
# with the counts or percentages of the different "regimes"

# Then I want a handful of individual journey plots demonstrating the different regimes

# I should have my "boundary" graphic at the bottom as well

# Messing with different text per report:

# `r if(params$showPI) "This text will only appear with PI graphics."`
# `r if(params$showAll) "This text will only appear with ALL graphics."`


```

  
```{r include = FALSE}

knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.height=7, fig.width=10)

# adjust graphic parameters

oldPar <- par(cex.main = 3,
    cex.lab = 3,
    cex.axis = 2,
    mar = c(5.1,4.1,4.1,2.1), # default is c(5.1,4.1,4.1,2.1)
    mfrow = c(1,1)
    )

```


```{r}

##########
## LOAD ##
##########

journeyPopulation <- readRDS(here::here("Data", "journeyPopulation.rds") )
piEMPLIDs <- readRDS(here::here("Data", "piEMPLIDs.rds") )

exc_diff <- readRDS(here::here("Data", "exclusiveJourney_timeDiff.rds") )
cj_diff <- readRDS(here::here("Data", "concurrentJourney_timeDiff.rds") )

cjEmplids <- readRDS(here::here("Data", "Journey Activity from Brute Force Fit Approximation for Concurrent Journey Employees.rds"))
excEmplids <- readRDS(here::here("Data", "Journey Activity from Brute Force Fit Approximation for Exclusive Journey Employees.rds"))

univBound_cj <- readRDS(here::here("Data", "Brute Force Fit Approximation for Concurrent Journey Employees.rds") )
univBound_exc <- readRDS(here::here("Data", "Brute Force Fit Approximation for Exclusive Journey Employees.rds") )

source(here::here("Functions", "Turnover Functions.R"))
source(here::here("Functions", "Brute Force Functions.R"))


library(lubridate)
library(RColorBrewer)

```

```{r}

###############
## FUNCTIONS ##
###############






```

```{r}

##########
## PREP ##
##########

# Full journey data set
univBound <- rbind(univBound_cj, univBound_exc)


# flowchart conditionals
journeyPopulation$wb <- journeyPopulation$WORKBREAK == "wb"
journeyPopulation$lv <- journeyPopulation$LEAVE == "leave"

journeyPopulation$PI <- journeyPopulation$EMPLID %in% piEMPLIDs
journeyPopulation$singleJob <- journeyPopulation$HCJ == "not_hcj" & journeyPopulation$SINGLERCD == "single_rcd"



```



**PURPOSE:**  The purpose of this report is to describe an effort to accurately calculate University headcount using an algorithm that I am calling a "brute force fit."


**OBJECTIVES:**
  (1)  Describe the problem and the resolution path.  
  (2)  Explain possible next steps.    
  (3)  Show the breakdown of the population by entry and exit actions.  
  (4)  Show examples of individual journeys from various sub-sets of the population with the blue line that is the "force-fit" approximation.  
  (5)  Show the resulting headcount estimation since 2010. 

**MEETING NOTES, 10/23/2025:**

Attendance:  Kirsten Allen, Brian Gelsinger, David Howell, Bill Prisbrey 

Action Items: 

- Brian will provide a SQL query that will provide a list of EMPLIDs and basic fields like department or college on snapshot dates (Jan/July) going back five to ten years.  Estimated completion date of Friday 10/31/2025. 
- Bill will proceed with the next steps, including using the snapshot data as a validation data set, focusing on the chemical engineering department.   


Notes:  

- Bill reviewed this report with the team.  
- The resulting headcount is too high: Brian's dashboard shows ~30,000 current employees while the headcount estimate shows about ~40,000 current employees. 
- Brian will provide snapshot data to guide improving the algorithm.  

### Problem and resolution path explained 

**ISSUE:**  An accurate headcount is critical to analyzing turnover.  Turnover is usually calculated as a rate, or as the number of employees departing divided by the headcount.  

**DIFFICULTY:**  Calculating the headcount for employees who have one job a time is straight-forward:  they are added to the headcount when they are hired and subtracted when they leave.  

However, many employees at the University of Utah hold concurrent positions.  Each position will have its own actions possibly affecting headcount:  one position will be terminated, but not the other; or one will commence a work break and not the other.  This already-complex record may have been further muddied by inconsistent record-keeping over time and across departments.  

These concurrent positions do not have distinct identifiers in the database.  An employee may start with one position, add a second, and then quit the first.  The identifier of the second position will be changed to match the identifier of the first.  

Accurately tallying headcount for these employees is challenging.  They are easily double-counted or double-deducted from the headcount. 

**RESOLUTION:**  

Each employee is considered one at a time, and the following algorithm is applied: 

  - Every "entry" action increases the cumulative headcount.  
  - Every "exit" action decreases the cumulative headcount.  
  - Because an employee is considered one at a time, a headcount value greater than one or less than zero is not allowed.  
  - A "university-level" boundary date can then be extracted per individual. 


### Next steps  

  *(1)  Validate and verify.*   Although this method produces an internally-consistent data set, where the number of entries does not exceed the number of exits for example, additional validation is sought.   
  
  *(2)  Add transfer events.*  Employees frequently transfer between positions, titles, and departments.   Adding transfer events will improve the granularity of the analysis.   
  
  *(3)  Include transfers to unpaid positions as 'exit' boundary events.*  Many employees are never terminated but are transferred to volunteer positions.   It may be desirable to exclude these individuals from a headcount tally.    
  
  

### Population breakdown by journey characteristics 

```{r eval=params$showPI}

################
## FLOWHCHART ##
################

library(flowchart)

# Showing split between concurrent and non-concurrent jobs

journeyPopulation |>
  as_fc(label = "Workforce population", text_fs = 12) |>
  fc_filter(PI, label = "Principal investigators", show_exc = TRUE) |>
  #fc_split(PI, label = c("Not PI", "PI")) |>
  fc_split(singleJob, label = c("Concurrent jobs", "No concurrent jobs"), bg_fill = "ivory", text_fs = 12) |> 
  fc_draw()


journeyPopulation |>
  (\(x){x[x$PI & !x$singleJob,]})() |>
  as_fc(label = "Concurrent jobs", text_fs = 12) |>
  fc_split(wb, label = c("No work break", "Work break"), bg_fill = "mintcream", text_fs = 12) |>
  fc_split(lv, label = c("No leave", "leave"), bg_fill = "plum1", text_fs = 12) |>
  fc_draw()


journeyPopulation |>
  (\(x){x[x$PI & x$singleJob,]})() |>
  as_fc(label = "Exclusive jobs", text_fs = 12) |>
  fc_split(wb, label = c("No work break", "Work break"), bg_fill = "mintcream", text_fs = 12) |>
  fc_split(lv, label = c("No leave", "leave"), bg_fill = "plum1", text_fs = 12) |>
  fc_draw()

```


```{r eval=params$showAll}

################
## FLOWHCHART ##
################

library(flowchart)

# Showing split between concurrent and non-concurrent jobs

journeyPopulation |>
  as_fc(label = "Workforce population", text_fs = 12) |>
  #fc_filter(PI, label = "Principal investigators", show_exc = TRUE) |>
  #fc_split(PI, label = c("Not PI", "PI")) |>
  fc_split(singleJob, label = c("Concurrent jobs", "No concurrent jobs"), bg_fill = "ivory", text_fs = 12) |> 
  fc_draw()


journeyPopulation |>
  (\(x){x[!x$singleJob,]})() |>
  as_fc(label = "Concurrent jobs", text_fs = 12) |>
  fc_split(wb, label = c("No work break", "Work break"), bg_fill = "mintcream", text_fs = 12) |>
  fc_split(lv, label = c("No leave", "leave"), bg_fill = "plum1", text_fs = 12) |>
  fc_draw()


journeyPopulation |>
  (\(x){x[x$singleJob,]})() |>
  as_fc(label = "Exclusive jobs", text_fs = 12) |>
  fc_split(wb, label = c("No work break", "Work break"), bg_fill = "mintcream", text_fs = 12) |>
  fc_split(lv, label = c("No leave", "leave"), bg_fill = "plum1", text_fs = 12) |>
  fc_draw()

```



### Individual journeys 

#### **EXCLUSIVE JOURNEY**

```{r eval=params$showPI, fig.height=5}



exc_wb_lv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

exc_nwb_nlv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

exc_wb_nlv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

exc_nwb_lv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

exclusivePopulation <- list(exc_wb_lv, exc_nwb_nlv, exc_wb_nlv, exc_nwb_lv)

set.seed(99)
excSample <- sapply(exclusivePopulation, function(x){sample(x,1)} )

# Plot it

par(mfrow = c(1,1))
plotJourneyKey()

par(mfrow = c(2,1), mar = c(0,2,2,1))
#
for(pi in excSample) {
  
exc_diff[[paste(pi,"0", sep = ".")]] |>
  assignBoundaries() |>
  plotJourney()

addVerticals(univBound[grep(pi, row.names(univBound)),])
  
exc_diff[[paste(pi,"0", sep = ".")]] |>
  forceFitPlot(fitLine = TRUE)    

}

```



```{r eval=params$showAll, fig.height=5 }



exc_wb_lv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

exc_nwb_nlv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

exc_wb_nlv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

exc_nwb_lv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

exclusivePopulation <- list(exc_wb_lv, exc_nwb_nlv, exc_wb_nlv, exc_nwb_lv)

set.seed(99)
excSample <- sapply(exclusivePopulation, function(x){sample(x,1)} )

# Plot it

par(mfrow = c(1,1))
plotJourneyKey()

par(mfrow = c(2,1), mar = c(0,2,2,1))
#
for(pi in excSample) {
  
exc_diff[[paste(pi,"0", sep = ".")]] |>
  assignBoundaries() |>
  plotJourney()

addVerticals(univBound[grep(pi, row.names(univBound)),])
  
exc_diff[[paste(pi,"0", sep = ".")]] |>
  forceFitPlot(fitLine = TRUE)    

}

```



#### **CONCURRENT JOURNEY**


```{r eval=params$showPI}

conc_wb_lv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

conc_nwb_nlv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

conc_wb_nlv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

conc_nwb_lv <- journeyPopulation$EMPLID[journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

concurrentPopulation <- list(conc_wb_lv, conc_nwb_nlv, conc_wb_nlv, conc_nwb_lv)

set.seed(99)
concSample <- sapply(concurrentPopulation, function(x){sample(x,1)} )

# Plot it

par(mfrow = c(1,1))
plotJourneyKey()

par(mfrow = c(2,1), mar = c(0,2,2,1))

for(pi in concSample) {
  
cjEmplids[[pi]] |>
  assignBoundaries() |>
  plotJourney()

addVerticals(univBound[grep(pi, row.names(univBound)),])
  
cjEmplids[[pi]] |>
  forceFitPlot(fitLine = TRUE)

}




```



```{r eval=params$showAll}

conc_wb_lv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

conc_nwb_nlv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

conc_wb_nlv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           journeyPopulation$wb &
                                           !journeyPopulation$lv
                                           ]

conc_nwb_lv <- journeyPopulation$EMPLID[#journeyPopulation$PI &
                                           !journeyPopulation$singleJob &
                                           !journeyPopulation$wb &
                                           journeyPopulation$lv
                                           ]

concurrentPopulation <- list(conc_wb_lv, conc_nwb_nlv, conc_wb_nlv, conc_nwb_lv)

set.seed(99)
concSample <- sapply(concurrentPopulation, function(x){sample(x,1)} )

# Plot it

par(mfrow = c(1,1))
plotJourneyKey()

par(mfrow = c(2,1), mar = c(0,2,2,1))

for(pi in concSample) {
  
cjEmplids[[pi]] |>
  assignBoundaries() |>
  plotJourney()

addVerticals(univBound[grep(pi, row.names(univBound)),])
  
cjEmplids[[pi]] |>
  forceFitPlot(fitLine = TRUE)

}




```



### Headcount Metrics 

#### **EXCLUSIVE JOBS**

```{r eval=params$showPI}

univBound_exc |>
  (\(x){x$EMPLID <- gsub("\\.[[:digit:]]+$", "", row.names(x)); return(x) })() |>
  (\(x){x[x$EMPLID %in% piEMPLIDs, ] })() |> 
    calculateMetrics_univ(minDate = ymd("2010-01-01")) |>
  plotMetrics_univ(plotList = c("cumulative", "delta.count"), title_mtext_params = list(
  text = "PI's with exclusive jobs"
  ))

```


```{r eval=params$showAll}

univBound_exc |>
  (\(x){x$EMPLID <- gsub("\\.[[:digit:]]+$", "", row.names(x)); return(x) })() |>
#  (\(x){x[x$EMPLID %in% piEMPLIDs, ] })() |> 
    calculateMetrics_univ(minDate = ymd("2010-01-01")) |>
  plotMetrics_univ(plotList = c("cumulative", "delta.count"), title_mtext_params = list(
  text = "All employees with exclusive jobs"
  ))

```




#### **CONCURRENT JOBS**

```{r eval=params$showPI}


univBound_cj |>
  (\(x){x$EMPLID <- gsub("\\.[[:digit:]]+$", "", row.names(x)); return(x) })() |>
  (\(x){x[x$EMPLID %in% piEMPLIDs, ] })() |> 
    calculateMetrics_univ(minDate = ymd("2010-01-01")) |>
  plotMetrics_univ(plotList = c("cumulative", "delta.count"), title_mtext_params = list(
  text = "PI's with concurrent jobs"))


```


```{r eval=params$showAll}


univBound_cj |>
  (\(x){x$EMPLID <- gsub("\\.[[:digit:]]+$", "", row.names(x)); return(x) })() |>
#  (\(x){x[x$EMPLID %in% piEMPLIDs, ] })() |> 
    calculateMetrics_univ(minDate = ymd("2010-01-01")) |>
  plotMetrics_univ(plotList = c("cumulative", "delta.count"), title_mtext_params = list(
  text = "All employees with concurrent jobs"))


```



#### **FULL POPULATION**

```{r eval=params$showPI}

univBound |>
  (\(x){x$EMPLID <- gsub("\\.[[:digit:]]+$", "", row.names(x)); return(x) })() |>
  (\(x){x[x$EMPLID %in% piEMPLIDs, ] })() |> 
    calculateMetrics_univ(minDate = ymd("2010-01-01")) |>
  plotMetrics_univ(plotList = c("cumulative", "delta.count"), title_mtext_params = list(
  text = "All PI's"))

```

```{r eval=params$showAll}

univBound |>
  (\(x){x$EMPLID <- gsub("\\.[[:digit:]]+$", "", row.names(x)); return(x) })() |>
#  (\(x){x[x$EMPLID %in% piEMPLIDs, ] })() |> 
    calculateMetrics_univ(minDate = ymd("2010-01-01")) |>
  plotMetrics_univ(plotList = c("cumulative", "delta.count"), title_mtext_params = list(
  text = "All employees"))

```

### Explain HeadCount

```{r}

explainHeadCount()

```  

'Exit' condition needs to be modified to accommodate the transfer to volunteer positions

*Per Brian Gelsinger, Teams message on 14 Oct 2025:*

I can't remember if we included the field UU_BEN_IND in the SQL we provided, but that would be my recommendation to use. A Benefit Indicator of "30 " means that job code is considered "Non-Employee". I'm happy to add that field to the SQL if you'd like, but below is a list of all the job codes in Ben Ind 30, so you could just try excluding those job codes as well. I've also provided the current headcount of employees in these job codes
 
Job Code	Job Title	UU Ben Ind	UU Ben Ind Descr	Count Distinct EE
0233	Field Instructor	30	Non-Employee	15
6000	Volunteer Staff	30	Non-Employee	21
6001	Volunteer Faculty	30	Non-Employee	34
6002	Adjunct Professor	30	Non-Employee	474
6003	Adjunct Associate Professor	30	Non-Employee	371
6004	Adjunct Assistant Professor	30	Non-Employee	748
6005	Adjunct Instructor	30	Non-Employee	588
6006	Shared Faculty (Unpaid)	30	Non-Employee	17
6100	Univ Asia Staff	30	Non-Employee	56
6102	Adjunct Professor (Ext)	30	Non-Employee	134
6103	Adjunct Assoc Professor (Ext)	30	Non-Employee	126
6104	Adjunct Asst Professor (Ext)	30	Non-Employee	784
6105	Adjunct Instructor (Ext)	30	Non-Employee	416
7993	Surviving Spouse	30	Non-Employee	0
9261	COBRA Beneficiary	30	Non-Employee	0
799999	Volunteer Staff	30	Non-Employee	0 



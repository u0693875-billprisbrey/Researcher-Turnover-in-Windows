---
title: "Workforce Journey Exploratory Data Analysis"
author: "Bill Prisbrey"
date: "2025-06-19"
output:
  html_document:
    keep_md: true
---


```{r settings, include = FALSE}

knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, error=FALSE,
                      fig.height=5, fig.width=7)

# fig.height=6.75, fig.width=12) for ppt
# fig.height=7, fig.width=10) typical report


# adjust graphic parameters

oldPar <- par(cex.main = 3,
    cex.lab = 3,
    cex.axis = 2,
    mar = c(5.1,4.1,4.1,2.1) # default is c(5.1,4.1,4.1,2.1)
    )

# par(oldPar) #restore old parameters # restore old parameters after the plot

library(kableExtra)

```


```{r}

##########
## LOAD ##
##########

# PREP SCRIPT

source(here::here("Prep scripts","Adjusting prepData and loading things.R"))

# PER PI

piClusters <- lapply(list.files(here::here("Robjects", "Clustering PIs"), full.names = TRUE), readRDS)

###########
## MERGE ## 
###########

piEmplid <- Reduce(function(x, y) {
  merged <- merge(x, y, by = "emplid", all = FALSE)
  merged <- merged[, !duplicated(sub("\\.x$|\\.y$", "", names(merged)))]  # Remove duplicate columns
  
  # Rename columns to remove ".x"
  names(merged) <- sub("\\.x$", "", names(merged))
  
  merged
}, piClusters)
# piEmplid <- Reduce(function(x, y) merge(x, y, by = "emplid", all = FALSE), piClusters)
# piEmplid <- do.call(merge, piClusters)



prepData <- merge(prepData, piEmplid[,c("emplid","complex_cluster","rate_cluster")], by.x =  "PROPOSAL_PI_EMPLID", by.y = "emplid", all.x = TRUE)

##########
## PREP ##
##########

piEmplid$combined_cluster <-  factor(paste(piEmplid$complex_cluster, piEmplid$rate_cluster, sep = ", "))

prepData$combined_cluster <- factor(paste(prepData$complex_cluster, prepData$rate_cluster, sep = ", "))

###############
## LIBRARIES ##
###############

library(viridis)
library(pheatmap)

#########
## MAP ##
#########

piMap <- data.frame(college = row.names(piEmplid), abbrv = row.names(piEmplid), color = NA, pch = 19, cex = 0.7 )

# I need the college map of colors

fullEmplid <- calculateWinRates(data = cleanData, categoryColumn = "PROPOSAL_PI_EMPLID") |>
  (\(x){x[[1]]})()

fullEmplid$count.total <- apply(fullEmplid[,c("win.count","loss.count")],1,sum)

filterTwoCount <- fullEmplid$count.total >= 2
# filterThreeCount <- piEmplid$count.total > 3


```



```{r}

###########
## QUERY ##
###########

# Obtain age data

keyring::keyring_unlock(keyring = "BIPR", password = "Excelsior!")

library(DBI)
con.ds <- DBI::dbConnect(odbc::odbc(), 
                         Driver = "oracle", 
                         Host = "ocm-campus01.it.utah.edu", 
                         SVC = keyring::key_list(keyring = "BIPR")[1, 1],
                         UID = keyring::key_list(keyring = "BIPR")[1, 2],
                         PWD = keyring::key_get(keyring = "BIPR", 
                         service = keyring::key_list(keyring = "BIPR")[1,1]),
                         Port = 2080)

journeyQuery <- "select * from ds_hr.EMPL_AGE_RANGE_ACTION_MV_V" # a view of that same query

journeyData <- dbGetQuery(con.ds, journeyQuery)

DBI::dbDisconnect(con.ds)


```

```{r}

##########
## PREP ##
##########

# Create factors with levels in the proper order
journeyData$AGE_BAND <- factor(journeyData$AGE_BAND, levels = 
                                 c(
                                   "Under 20",
                                   "20s",
                                   "30s",
                                   "40s",
                                   "50s",
                                   "60s",
                                   "70s",
                                   "80s",
                                   "90 and Above"
                                 )
                                 )

# Remove a bad date
#> journeyData[journeyData$EFFDT > as.Date("2030-12-31"),]
#          EMPLID EMPL_RCD      EFFDT EFFSEQ ACTION     ACTION_DESCR ACTION_REASON
#1950047 06013186        0 2202-11-21      0    LOA Leave of Absence           EXT
#        ACTION_REASON_DESCR VOLUNTARY_FLAG AGE_BAND
# 1950047           Extension           <NA>      30s

journeyData <- journeyData[journeyData$EFFDT <= as.Date("2030-12-31"),]

```


```{r}

uniqueActions <- unique(journeyData[,c("ACTION", "ACTION_DESCR")])
actionCount <- table(journeyData[,c("ACTION")]) 
actionFrame <- merge(uniqueActions, data.frame(ACTION = names(actionCount), count = as.vector(actionCount)), by = "ACTION")


uniqueReasons <- unique(journeyData[, c("ACTION_REASON","ACTION_REASON_DESCR")])
reasonCount <- table(journeyData[, "ACTION_REASON"])
reasonFrame <- merge(uniqueReasons, data.frame(ACTION_REASON = names(reasonCount), count = as.vector(reasonCount)), by = "ACTION_REASON")


# Association between action and reason

actionReasonCombo <- table(journeyData[,c("ACTION", "ACTION_DESCR",  "ACTION_REASON", "ACTION_REASON_DESCR")]) |>
  as.data.frame() |>
  (\(x){ x[x$Freq>0,]})() |>
  (\(x){x[order(x$ACTION),]  })()

actionsPerReason <- aggregate(ACTION ~ ACTION_REASON, journeyData, function(x){length(unique(x))} ) |>
  (\(x){x[x$ACTION >1,]})()


reasonsPerAction <- aggregate(ACTION_REASON ~ ACTION + ACTION_DESCR, journeyData, function(x){length(unique(x))} )  


```


**PURPOSE:**  The purpose of this report is 

**OBJECTIVES:**   

  1.  Describe the "Workforce Journey" data.   
  2.  Summarize data for the target population.    
  3.  Calculate headcount.

**EXECUTIVE SUMMARY:**

The

**SUMMARY:**   

One row with a bad date ("2202-11-21") is filtered out.

Several of these actions look like they overlap as far as I'm concerned--
"RET" or "TERM"

I want a query that just pulls the actions, reasons, and descriptions.

Do I look at the correlation between actions and reasons?


## (1) DESCRIBE THE WORKFORCE JOURNEY DATA

### Data summary

```{r}

skim(journeyData)

```

```{r}

merge(actionFrame, reasonsPerAction[,c("ACTION","ACTION_REASON")], by = "ACTION") |>
  kbl(caption = "Actions and reasons",
      col.names = c("", "description", "count", "unique\nreasons"),
      row.names=FALSE,
      escape = FALSE) |>  
  kable_styling(full_width = FALSE) 


```

```{r}

reasonFrame |>
  kbl(caption = "Action reasons",
      col.names = c("", "description","count"),
      row.names=FALSE,
      escape = FALSE) |>  
  kable_styling(full_width = FALSE) |>
  scroll_box(height = "1000px")

```

```{r}



actionReasonCombo |>
  kbl(caption = "Actions and reasons",
      col.names = c("", "action", "reason", "description",  "count"),
      row.names=FALSE,
      escape = FALSE) |>  
  kable_styling(full_width = FALSE) |>
  scroll_box(height = "1000px")


actionReasonCombo[actionReasonCombo$ACTION_REASON %in% actionsPerReason$ACTION_REASON,] |>
  (\(x){x[order(x$ACTION_REASON),]})() |>
  kbl(caption = "Reasons applied to multiple actions",
      col.names = c("", "action", "reason","description", "count"),
      row.names=FALSE,
      escape=FALSE
  ) |>  
  kable_styling(full_width = FALSE) |>
  scroll_box(height = "1000px")

actionReasonCombo[!(actionReasonCombo$ACTION_REASON %in% actionsPerReason$ACTION_REASON),] |>
#  (\(x){x[order(x$ACTION_REASON),]})() |>
  kbl(caption = "Reasons applied to a single action",
      col.names = c("", "action", "reason","description", "count"),
      row.names=FALSE,
      escape=FALSE
  ) |>  
  kable_styling(full_width = FALSE) |>
  scroll_box(height = "1000px")



```


```{r}

# Age distribution

journeyData$AGE_BAND |>
  table() |>
  barplot(col = viridis::viridis(n=length(levels(journeyData$AGE_BAND)), dir = -1),
  ylab = "record count",
  main = "Age distribution of action events")



```


```{r}

# Action items per PI

eventsPerEmplid <- aggregate(ACTION ~ EMPLID, data = journeyData, length)
names(eventsPerEmplid) <- c("EMPLID", "eventCount")


theHist <- hist(log(eventsPerEmplid$eventCount), plot = FALSE)


plot(theHist, col = viridis::mako(n = length(theHist$breaks)),
     main = "Events per EMPLID (log)",
     ylab = "count of EMPLID",
     xlab = "events per EMPLID (log)"
     )


```


```{r eval=FALSE}

# termination flag check

table(journeyData[,c("ACTION","VOLUNTARY_FLAG")], useNA = "always") # o.k.

# actions per employee

actionsPerEmplid <- aggregate(count ~ EMPLID + ACTION, 
          data = transform(journeyData, count = 1), 
          FUN = sum)

actionsPerEmplid[actionsPerEmplid$ACTION == "TER","count"] |> hist()

# can I align rehire and termination dates?
# can I see if someone was involuntarily terminated multiple times?

```


```{r}

# Termination flag

termFlag <- aggregate(rep(1, nrow(journeyData)) ~ VOLUNTARY_FLAG, data = journeyData, length )

log(termFlag[,2]) |> 
  barplot(col = c("slateblue4", "saddlebrown"),
          names = termFlag[,1],
          main = "Termination flag",
          ylab = "count (log)"
          )


```

```{r}

# Actions over time

actionsInOrder <-  c("POS", "DTA", "PAY", "TER", "HIR", "SWB", "XFR", "RWB", "REH", "JRC", "PLA", "RFL", "LOA", "RET", "RWP", "LTO", "TWP")

actionsPerDate <- lapply(actionsInOrder, function(x){ aggregate(count ~ EFFDT,  data = transform(journeyData[journeyData$ACTION == x,], count =1), length)}   )
names(actionsPerDate) <- actionsInOrder # unique(journeyData$ACTION)

# Determine maximum per action
actionDateMax <- sapply(actionsPerDate, function(x) {max(x[,"count"],na.rm=TRUE )}) |> max() 

# Sort into clusters
actionDateCluster <- 
  actionsPerDate |> 
  sapply(function(x){mean(x[,"count"], na.rm = TRUE)}) |>
  dist() |>
  hclust() |>
  # plot() # looks like 3 is reasonable
  cutree(3)

# Establish decreasing order of mean count
meanCount <- actionsPerDate |> 
     sapply(function(x){mean(x[,"count"], na.rm = TRUE)}) |> sort(decreasing = TRUE)

# Use this to define "actionsInOrder"
# It would be better if I re-ordered it here as this is no longer
# flexible to add a new action

# Establish maximum per cluster

clusterMax <- sapply(1:3,
                     function(y) {
                       
                       sapply(actionsPerDate[actionDateCluster == y ], function(x) {max(x[,"count"], na.rm=TRUE)}  ) 
                     }
                     )

# Create color map per action

# create action colors

actionColorMap <- vector("numeric", length(actionDateCluster))

names(actionColorMap) <- names(actionDateCluster)

actionColorMap[actionDateCluster == 3] <- viridis::viridis(n = length(actionDateCluster[actionDateCluster == 3]))

actionColorMap[actionDateCluster == 2] <- viridis::turbo(n = length(actionDateCluster[actionDateCluster == 2]), begin = 0.3, end = 0.7)

actionColorMap[actionDateCluster == 1] <- viridis::mako(n = length(actionDateCluster[actionDateCluster == 1]))

# Function to plot a cluster at a time

plotActions <- function(cluster) {

incomingPar <-  par(mar = c(2,4,3,6))
on.exit(par(incomingPar))


plot(1,
     type = "n",
     ylim = log(c(1,max(clusterMax[[cluster]]))),
     xlim = range(as.Date(journeyData$EFFDT)),
     ylab = "",
     xlab = "",
     xaxt = "n"
     )

axis.Date(side = 1, at = pretty(as.Date(journeyData$EFFDT)), format = "%Y-%m")

invisible(
  lapply(
    names(actionDateCluster[actionDateCluster == cluster]),
    function(act){
    
    points(x = as.Date(actionsPerDate[[act]][,"EFFDT"]),
           y = log(actionsPerDate[[act]][,"count"]),
           col = actionColorMap[act],
           type = "l",
           lwd = 0.619
    )
      
    }
  )
)

mtext(side = 3, font=2, cex = 1.381, line = 0.619, text = paste0("Actions in Cluster ", cluster)  )

mtext(side = 2, font = 1, cex = 1, line = 2.5, text = "Count of actions (log)")

legend("topright",
       legend = names(actionDateCluster[actionDateCluster == cluster]),
       col = actionColorMap[actionDateCluster == cluster],
       pch = 19,
       pt.cex = 3,
       xpd = TRUE,
       inset = -0.1
       )



}



```

### Count of actions per date

```{r fig.height = 3}

# Plot the count of actions per date, one plot per cluster

plotActions(cluster=1)
plotActions(cluster=2)

```

```{r fig.height = 5}

plotActions(cluster=3)


```


```{r eval=FALSE}

# Dates sandbox

# One line per action over time

jGo <- aggregate(EFFDT ~ ACTION, data = journeyData, function(x){length(unique(x))})

skim(journeyData$EFFDT)

tBlo <- lapply(unique(journeyData$ACTION), function(x){ aggregate(count ~ EFFDT,  data = transform(journeyData[journeyData$ACTION == x,], count =1), length)}   )
names(tBlo) <- unique(journeyData$ACTION)

actionDateMax <- sapply(tBlo, function(x) {max(x[,"count"],na.rm=TRUE )}) |> max() 


# let's lump these

actionDateCluster <- 
  tBlo |> 
  sapply(function(x){mean(x[,"count"], na.rm = TRUE)}) |>
  dist() |>
  hclust() |>
  # plot() # looks like 3 is reasonable
  cutree(3)
  
names(tBlo)

clusterMax <- sapply(1:3,
                     function(y) {
                       
                       sapply(tBlo[actionDateCluster == y ], function(x) {max(x[,"count"], na.rm=TRUE)}  ) 
                     }
                     )

# well, let's plot it and see what we get
# create action colors

actionColorMap <- vector("numeric", length(actionDateCluster))

names(actionColorMap) <- names(actionDateCluster)

actionColorMap[actionDateCluster == 1] <- viridis::viridis(n = length(actionDateCluster[actionDateCluster == 1]))

actionColorMap[actionDateCluster == 2] <- viridis::turbo(n = length(actionDateCluster[actionDateCluster == 2]), begin = 0.3, end = 0.7)

actionColorMap[actionDateCluster == 3] <- viridis::mako(n = length(actionDateCluster[actionDateCluster == 3]))

plotActions <- function(cluster) {

incomingPar <-  par(mar = c(2,4,3,6))
on.exit(par(incomingPar))


plot(1,
     type = "n",
     ylim = c(0,max(clusterMax[[cluster]])),
     xlim = range(as.Date(journeyData$EFFDT)),
     ylab = "",
     xlab = "",
     xaxt = "n"
     )

axis.Date(side = 1, at = pretty(as.Date(journeyData$EFFDT)), format = "%Y-%m")

invisible(
  lapply(
    names(actionDateCluster[actionDateCluster == cluster]),
    function(act){
    
    points(x = as.Date(tBlo[[act]][,"EFFDT"]),
           y = tBlo[[act]][,"count"],
           col = actionColorMap[act],
           type = "l",
           lwd = 0.619
    )
      
    }
  )
)

mtext(side = 3, font=2, cex = 1.381, line = 0.619, text = paste0("Actions in Cluster ", cluster)  )

legend("topright",
       legend = names(actionDateCluster[actionDateCluster == cluster]),
       col = actionColorMap[actionDateCluster == cluster],
       pch = 19,
       pt.cex = 3,
       xpd = TRUE,
       inset = -0.1
       )



}


plotActions(cluster = 1)


plotActions(cluster = 2)
mtext(side = 3, font=2, cex = 1.381, line = 0.619, text ="Actions in Cluster 2"  )
legend("topright",
       legend = names(actionDateCluster[actionDateCluster == 2]),
       col = actionColorMap[actionDateCluster == 2],
       pch = 19,
       pt.cex = 3,
       xpd = TRUE,
       inset = -0.1
       )

plotActions(cluster = 3)
mtext(side = 3, font=2, cex = 1.381, line = 0.619, text ="Actions in Cluster 3"  )
legend("topright",
       legend = names(actionDateCluster[actionDateCluster == 3]),
       col = actionColorMap[actionDateCluster == 3],
       pch = 19,
       pt.cex = 3,
       xpd = TRUE,
       inset = -0.1
       )
```

### Seasonality

```{r}

# let's do week of year

actionsPerWeek <- lapply(actionsInOrder, function(x){ aggregate(count ~ week(EFFDT),  data = transform(journeyData[journeyData$ACTION == x,], count =1), length)}   )
names(actionsPerWeek) <- actionsInOrder # unique(journeyData$ACTION)


# Establish weekly maximum per cluster

clusterWeekMax <- sapply(1:3,
                     function(y) {
                       
                       sapply(actionsPerWeek[actionDateCluster == y ], function(x) {max(x[,"count"], na.rm=TRUE)}  ) 
                     }
                     )


plotWeeklyActions <- function(cluster) {

incomingPar <-  par(mar = c(4,4,3,6))
on.exit(par(incomingPar))


plot(1,
     type = "n",
     ylim = log(c(1,max(clusterWeekMax[[cluster]]))),
     xlim = range(week(journeyData$EFFDT)),
     ylab = "",
     xlab = "",
     xaxt = "n"
     )

axis(side = 1, at = pretty(week(journeyData$EFFDT)))

invisible(
  lapply(
    names(actionDateCluster[actionDateCluster == cluster]),
    function(act){
    
    points(x = actionsPerWeek[[act]][,"week(EFFDT)"],
           y = log(actionsPerWeek[[act]][,"count"]),
           col = actionColorMap[act],
           type = "l",
           lwd = 0.619
    )
      
    }
  )
)

mtext(side = 3, font=2, cex = 1.381, line = 0.619, text = paste0("Weekly actions in Cluster ", cluster)  )

mtext(side = 2, font = 1, cex = 1, line = 2.5, text = "Count of actions (log)")

mtext(side = 1, font = 1, cex = 1, line = 2.5, text = "Week of year")

legend("topright",
       legend = names(actionDateCluster[actionDateCluster == cluster]),
       col = actionColorMap[actionDateCluster == cluster],
       pch = 19,
       pt.cex = 3,
       xpd = TRUE,
       inset = -0.1
       )



}


```

```{r fig.height = 3}

# Plot the count of actions per date, one plot per cluster

plotWeeklyActions(cluster=1)
plotWeeklyActions(cluster=2)

```

```{r fig.height = 5}

plotWeeklyActions(cluster=3)


```



### Termination 

There seems to be several over-lapping actions and reasons, like a "RET" -and- a "TERM". 

It might be nice to explore these here.   

### Query

The query below is converted to a view, ds_hr.EMPL_AGE_RANGE_ACTION_MV_V.

"SELECT A.EMPLID, A.EMPL_RCD, A.EFFDT, A.EFFSEQ
    , A.ACTION, B.ACTION_DESCR
    , A.ACTION_REASON, C.DESCR ACTION_REASON_DESCR
    , Case when A.ACTION ! = 'TER' then ''
        when A.ACTION  = ('TER') 
        AND A.ACTION_REASON not in ('BNK', 'EVW', 'I9', 'INV', 'NER', 'RFN', 'RIF', 'RLS') 
        then 'Voluntary' else 'Involuntary' end VOLUNTARY_FLAG
    , Case    when (SYSDATE-D.BIRTHDATE)/365.25 < 20
        then 'Under 20' 
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 20  and (SYSDATE-D.BIRTHDATE)/365.25 < 30
        then '20s'
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 30  and (SYSDATE-D.BIRTHDATE)/365.25  < 40
        then '30s'
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 40  and (SYSDATE-D.BIRTHDATE)/365.25  < 50
        then '40s'
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 50  and (SYSDATE-D.BIRTHDATE)/365.25 < 60
        then '50s'
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 60  and (SYSDATE-D.BIRTHDATE)/365.25  < 70
        then '60s'
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 70  and (SYSDATE-D.BIRTHDATE)/365.25 < 80
        then '70s'
    when (SYSDATE-D.BIRTHDATE)/365.25 >= 80  and (SYSDATE-D.BIRTHDATE)/365.25 < 90
        then '80s'
    else '90 and Above'
        end Age_Band
        
FROM PS_UU_UNSEC_JOB_VW A
  JOIN PS_ACTION_TBL B
    ON (B.ACTION = A.ACTION
    AND B.EFFDT =
        (SELECT MAX(B_ED.EFFDT) FROM PS_ACTION_TBL B_ED
        WHERE B.ACTION = B_ED.ACTION
          AND B_ED.EFFDT <= SYSDATE))
  JOIN PS_ACTN_REASON_TBL C
    ON (C.ACTION = A.ACTION
     AND C.ACTION_REASON = A.ACTION_REASON
     AND C.EFFDT =
        (SELECT MAX(C_ED.EFFDT) FROM PS_ACTN_REASON_TBL C_ED
        WHERE C.ACTION = C_ED.ACTION
          AND C.ACTION_REASON = C_ED.ACTION_REASON
          AND C_ED.EFFDT <= SYSDATE))
    JOIN ps_personal_dt_fst D
        ON (D.EMPLID = A.EMPLID)
        
WHERE  A.EFFDT > TO_DATE('2010-01-01','YYYY-MM-DD')
    ORDER BY A.EMPLID, A.EMPL_RCD, A.EFFDT"
